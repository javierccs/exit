<?xml version='1.0' encoding='UTF-8'?>
<project>
  <actions/>
  <description></description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <name>PROJECT_NAME</name>
          <description></description>
          <defaultValue>TEST</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>GITLAB_URL</name>
          <description></description>
          <defaultValue></defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>GIT_BRANCH</name>
          <description></description>
          <defaultValue>development</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>MAIL_LIST</name>
          <description></description>
          <defaultValue>fdelamor@isban.es</defaultValue>
        </hudson.model.StringParameterDefinition>
      </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
  </properties>
  <scm class="hudson.scm.NullSCM"/>
  <assignedNode>master</assignedNode>
  <canRoam>false</canRoam>
  <disabled>false</disabled>
  <blockBuildWhenDownstreamBuilding>false</blockBuildWhenDownstreamBuilding>
  <blockBuildWhenUpstreamBuilding>false</blockBuildWhenUpstreamBuilding>
  <triggers/>
  <concurrentBuild>false</concurrentBuild>
  <builders>
    <javaposse.jobdsl.plugin.ExecuteDslScripts plugin="job-dsl@1.42">
      <scriptText>import jenkins.model.*

// Input parameters
def _PROJECT_NAME_ = &quot;${PROJECT_NAME}&quot;.trim()
def _GITLAB_URL_ = &quot;${GITLAB_URL}&quot;.trim()
def _MAIL_LIST_ = &quot;${MAIL_LIST}&quot;.trim()
def _BRANCH_ = &quot;${GIT_BRANCH}&quot;.trim()

def _PROJECT_TYPE_ = &quot;docker&quot;
def inst = Jenkins.getInstance()
def gitlab = inst.getDescriptor(&quot;com.dabsquared.gitlabjenkins.GitLabPushTrigger&quot;)
def _GITLAB_SERVER_ = gitlab.getGitlabHostUrl()
def _GITLAB_API_TOKEN_ = gitlab.getGitlabApiToken()
def _GITLAB_PROJECT_ = _GITLAB_URL_.minus(_GITLAB_SERVER_+&apos;/&apos;)
def JOB_NAME = &quot;wp-${_PROJECT_NAME_.replace(&quot; &quot;,&quot;_&quot;)}&quot;

def _REPOSITORY_=&apos;${ENV,var=\&quot;REPOSITORY\&quot;}&apos;

def credentialsId
def creds = com.cloudbees.plugins.credentials.CredentialsProvider.lookupCredentials(
  com.cloudbees.plugins.credentials.common.StandardUsernameCredentials.class,
  inst,
  null,
  null
);
for (c in creds) {
  if (c.description.equals(&apos;GreenLight Jenkins access&apos;)) {
     credentialsId = c.id
    }
  }

// Build job
job (JOB_NAME+&apos;-build&apos;) {
	println &quot;JOB: ${JOB_NAME}&quot;
    label(_PROJECT_TYPE_)
    deliveryPipelineConfiguration(&apos;CI&apos;, &apos;Build Image&apos;)

    logRotator(daysToKeep=30, numToKeep=10, artifactDaysToKeep=-1,artifactNumToKeep=-1)
                
		// Gives permission for the special authenticated group to see the workspace of the job
/*	authorization {
		permission(&apos;hudson.model.Item.Build&apos;, &quot;${BUILD_USER_ID}&quot;)
		permission(&apos;hudson.model.Item.Cancel&apos;, &quot;${BUILD_USER_ID}&quot;)
        permission(&apos;hudson.model.Item.Delete&apos;, &quot;${BUILD_USER_ID}&quot;)
		permission(&apos;hudson.model.Item.Discover&apos;, &quot;${BUILD_USER_ID}&quot;)
		permission(&apos;hudson.model.Item.Read&apos;, &quot;${BUILD_USER_ID}&quot;)
		permission(&apos;hudson.model.Item.Workspace&apos;, &quot;${BUILD_USER_ID}&quot;)
		permission(&apos;hudson.model.Run.Update&apos;, &quot;${BUILD_USER_ID}&quot;)
		//permission(&apos;hudson.plugins.release.ReleaseWrapper.Release&apos;, &quot;${BUILD_USER_ID}&quot;)	  
	} //authorization */

    parameters {
		// Defines a simple text parameter, where users can enter a string value.
		stringParam(&apos;gitlabActionType&apos;, &apos;PUSH&apos;, null)
  		stringParam(&apos;gitlabSourceRepoURL&apos;, _GITLAB_URL_, null)
  		stringParam(&apos;gitlabSourceRepoName&apos;, &apos;origin&apos;, null)
  		stringParam(&apos;gitlabSourceBranch&apos;, _BRANCH_, null)
  		stringParam(&apos;gitlabTargetBranch&apos;, _BRANCH_, null)
    }
  
	scm {
		git {
				// Specify the branches to examine for changes and to build.
			branch(&apos;${gitlabSourceRepoName}/${gitlabSourceBranch}&apos;)
				// Adds a repository browser for browsing the details of changes in an external system.
			browser {
				gitLab(_GITLAB_URL_, &apos;7.9&apos;)
			} //browser
				// Adds a remote.
			remote {
					// Sets credentials for authentication with the remote repository.
				credentials(credentialsId)
					// Sets a name for the remote.
				name(&apos;origin&apos;)
					// Sets the remote URL.
				url(_GITLAB_URL_)
			} //remote
          
            wipeOutWorkspace(true)
            mergeOptions(&apos;origin&apos;, &apos;${gitlabTargetBranch}&apos;)
	} //git
	} //scm

	triggers {
        gitlabPush {
            buildOnPushEvents(true)
            setBuildDescription(true)
            useCiFeatures(false)
            allowAllBranches(false)
            includeBranches(_BRANCH_)
        }
	} //triggers
  
    steps {
      shell(
&apos;#!/bin/bash\n&apos;+
&apos;#echo off\n&apos;+
&apos;export HOST_CHECKING=\&quot; -o StrictHostKeyChecking=no\&quot;\n&apos;+
&apos;export FILE_DOCKER_COMPOSE=\&quot;docker-compose.yml\&quot;\n&apos;+
&apos;export DOCKER_FILE=\&quot;DockerFile\&quot;\n&apos;+
&apos;export HOST_REGISTRY_BASE_IP=registry.lvtc.gsnet.corp\n&apos;+
&apos;export REGISTRY_BASE_LOGIN=registry.lvtc.gsnet.corp/\n&apos;+
&apos;export REGISTRY_BASE_URL=https://registry.lvtc.gsnet.corp\n&apos;+
&apos;#Need Parameters\n&apos;+
&apos;# JOB_NAME\n&apos;+
&apos;# JOB_INSTANCE\n&apos;+
&apos;export TAG_GIT=0.\\$BUILD_TAG-SNAPSHOT;\n&apos;+
&apos;# IMAGE MUST BE THE NAME OF GITLAB PROJECT\n&apos;+
&apos;REMOTE_REPO=\&quot;\$(git remote -v|tail -n1)\&quot;\n&apos;+
&apos;# GITLAB project\n&apos;+
&apos;IMAGE_NAME=\$(echo \$REMOTE_REPO| sed \&quot;s|.git .*||\&quot; |sed \&quot;s|.*/||\&quot;)\n&apos;+
&apos;# Group GITLAB\n&apos;+
&apos;GROUP_GITLAB=\$(echo \$REMOTE_REPO|sed \&quot;s|.git .*||\&quot; | sed \&quot;s|\$IMAGE_NAME||\&quot; | sed \&quot;s|/\$||\&quot; | sed \&quot;s|.*/||\&quot;)\n&apos;+
&apos;IMAGE_NAME_BASE=\&quot;\$(grep -HR \&quot;image:\&quot; \$FILE_DOCKER_COMPOSE | cut -f3 -d\&apos;:\&apos;| head -n1)\&quot;;\n&apos;+
&apos;IMAGE_NAME_BASE=\&quot;\${IMAGE_NAME_BASE#\&quot;\${IMAGE_NAME_BASE%%[![:space:]]*}\&quot;}\&quot;;   # elimina los espacios por delante\n&apos;+
&apos;IMAGE_NAME_BASE=\&quot;\${IMAGE_NAME_BASE%\&quot;\${IMAGE_NAME_BASE##*[![:space:]]}\&quot;}\&quot;;  # elimina los espacios por detrán\n&apos;+
&apos;if [ \&quot;\$IMAGE_NAME\&quot; == \&quot;\&quot; ]; then\n&apos;+
&apos;        echo \&quot;[ERROR] Name Docker Image doesnt exist\&quot;\n&apos;+
&apos;        exit 1;\n&apos;+
&apos;fi;\n&apos;+
&apos;echo \&quot;BASE IMAGE NAME:\&quot;\$IMAGE_NAME_BASE\n&apos;+
&apos;IMAGE_VERSION=\&quot;\$(grep -HR \&quot;image:\&quot; \$FILE_DOCKER_COMPOSE | cut -f4 -d\&apos;:\&apos;| head -n1)\&quot;;\n&apos;+
&apos;IMAGE_VERSION=\&quot;\${IMAGE_VERSION#\&quot;\${IMAGE_VERSION%%[![:space:]]*}\&quot;}\&quot;;   # elimina los espacios por delante\n&apos;+
&apos;IMAGE_VERSION=\&quot;\${IMAGE_VERSION%\&quot;\${IMAGE_VERSION##*[![:space:]]}\&quot;}\&quot;;  # elimina los espacios por detrán\n&apos;+
&apos;if [ \&quot;\$IMAGE_VERSION\&quot; == \&quot;\&quot; ]; then\n&apos;+
&apos;        IMAGE_VERSION=\&quot;latest\&quot;;\n&apos;+
&apos;fi;\n&apos;+
&apos;echo \&quot;version_imagen:\&quot;\$IMAGE_VERSION\n&apos;+
&apos;WPRESS_DATA_HOME=/tmp/data\n&apos;+
&apos;# moviendo ficheros del workspace al temporal\n&apos;+
&apos;if [ -a \&quot;\$DOCKER_FILE\&quot; ] # Review if void\n&apos;+
&apos;        then\n&apos;+
&apos;                echo \&quot;Docker file alerady exist\&quot;;\n&apos;+
&apos;                export WORDPRESS_DOCKERFILE=\&quot;\$(cat \$DOCKER_FILE)\&quot;\n&apos;+
&apos;        else\n&apos;+
&apos;                export WORDPRESS_DOCKERFILE=\&quot;FROM \$IMAGE_NAME_BASE:\$IMAGE_VERSION \\\n&apos;+
&apos;                \\n MAINTAINER serenity-alm@serenity.com \\\n&apos;+
&apos;                \\n ENV WPRESS_DATA_HOME  \$WPRESS_DATA_HOME \\\n&apos;+
&apos;                \\n\\nRUN mkdir \$WPRESS_DATA_HOME \\\n&apos;+
&apos;                \\n ADD ./wp-content \$WPRESS_DATA_HOME \\\n&apos;+
&apos;                \\n RUN if ls \$WPRESS_DATA_HOME/plugins; then cp -rd \$WPRESS_DATA_HOME/plugins/* /usr/src/wordpress/wp-content/plugins/; fi \\\n&apos;+
&apos;                \\n RUN if ls \$WPRESS_DATA_HOME/themes; then cp -rd \$WPRESS_DATA_HOME/themes/* /usr/src/wordpress/wp-content/themes/; fi \\\n&apos;+
&apos;                \\n RUN mkdir -p /usr/src/wordpress/uploads \\\n&apos;+
&apos;                \\n RUN if ls \$WPRESS_DATA_HOME/uploads; then cp -rd \$WPRESS_DATA_HOME/uploads/* /usr/src/wordpress/wp-content/uploads; fi \\\n&apos;+
&apos;                \\n RUN chown -R www-data:www-data /usr/src/wordpress \\\n&apos;+
&apos;                \\n LABEL com.serenity.imageowner=\\\&quot;Serenity-ALM\\\&quot; \\\n&apos;+
&apos;                \\n LABEL com.serenity.description=\\\&quot;Docker file generated by Serenity ALM - Wordpress base\\\&quot; \\\n&apos;+
&apos;                \\n LABEL com.serenity.image.version=\\\&quot;0.\$BUILD_TAG-SNAPSHOT\\\&quot; \\\n&apos;+
&apos;                \\n ENV com.serenity.imageowner=\\\&quot;Serenity-ALM\\\&quot; \\\n&apos;+
&apos;                \\n ENV com.serenity.description=\\\&quot;Docker file generated by Serenity ALM - Wordpress base\\\&quot; \\\n&apos;+
&apos;                \\n ENV com.serenity.image.version=\\\&quot;0.\$BUILD_TAG-SNAPSHOT\\\&quot; \&quot;\n&apos;+
&apos;fi\n&apos;+
&apos;echo \&quot;DOCKER_FILE:\&quot;\$WORDPRESS_DOCKERFILE\n&apos;+
&apos;echo -e \$WORDPRESS_DOCKERFILE &gt; Dockerfile\n&apos;+
&apos;export REPOSITORY=\$GROUP_GITLAB/\$IMAGE_NAME\n&apos;+
&apos;export DOCKER_HOST=\&quot;unix:///var/run/docker.sock\&quot;\n&apos;+
&apos;echo \&quot;REPOSITORY=\&quot;\$REPOSITORY &gt; env.properties\n&apos;+
&apos;echo \&quot;TAG_GIT=\&quot;\$TAG_GIT &gt;&gt; env.properties\n&apos;+
&apos;echo \&quot;DOCKER_HOST=\&quot;\$DOCKER_HOST &gt;&gt; env.properties\n&apos;+
&apos;echo \&quot;REPOSITORY:\&quot;\$REPOSITORY\n&apos;+
&apos;echo \&quot;TAG_GIT:\&quot;\$TAG_GIT\n&apos;+
&apos;echo \&quot;DOCKER_HOST:\&quot;\$DOCKER_HOST\n&apos;+
&apos;echo \&quot;\$(docker ps)\&quot;\n&apos;+
&apos;echo \&quot;\$(id)\&quot; &apos;
			)
			
		environmentVariables {
            propertiesFile(&apos;env.properties&apos;)
        }	
		
	 
      dockerBuildAndPublish {
			dockerRegistryURL(&quot;https://registry.lvtc.gsnet.corp&quot;)
            repositoryName(_REPOSITORY_)
            tag(&apos;0.$BUILD_TAG-SNAPSHOT&apos;)
            registryCredentials(credentialsId)
            forcePull(false)
            createFingerprints(false)
            skipDecorate()
        }
      
    }// steps
	 publishers {
         git {
            pushOnlyIfSuccess()
            tag(&apos;origin&apos;, &apos;0.$BUILD_TAG-SNAPSHOT&apos;) {
                message(&apos;DOCKER IMAGE TAG&apos;)
                create()
            }
        }
        downstream(JOB_NAME+&apos;-dev-deploy&apos;, &apos;SUCCESS&apos;)
    } //publishers

} //job

job (JOB_NAME+&apos;-dev-deploy&apos;) {
    deliveryPipelineConfiguration(&apos;Dev&apos;, &apos;Deploy image&apos;)
    steps {
        shell(&apos;echo Hello!&apos;)
    }
}

deliveryPipelineView(PROJECT_NAME) {
    allowPipelineStart()
	allowRebuild()
    columns(3)
    enableManualTriggers()
    pipelineInstances(3)
    showAggregatedPipeline()
    showAvatars()
    showChangeLog()
	showDescription()
	showPromotions()
	showTotalBuildTime()
    updateInterval(10)   
    pipelines {
        component(PROJECT_NAME, JOB_NAME+&apos;-build&apos;)
    }
} // deliveryPipelineView

def url = new URL(_GITLAB_SERVER_+&quot;/api/v3/projects/&quot;+java.net.URLEncoder.encode(_GITLAB_PROJECT_)+&quot;/hooks?&quot;+
                  &quot;private_token=&quot;+_GITLAB_API_TOKEN_+
                  &quot;&amp;url=&quot;+inst.getRootUrl()+&quot;project/&quot;+JOB_NAME+
                  &quot;&amp;merge_requests_events=true&amp;push_events=true&quot;)
println &quot;Create hook: &quot;+url

/*def connection = url.openConnection()
connection.setRequestMethod(&quot;POST&quot;)
connection.doOutput = true
connection.connect()
	
println connection.content.text
assert connection.responseCode == 201*/</scriptText>
      <usingScriptText>true</usingScriptText>
      <ignoreExisting>false</ignoreExisting>
      <removedJobAction>IGNORE</removedJobAction>
      <removedViewAction>IGNORE</removedViewAction>
      <lookupStrategy>JENKINS_ROOT</lookupStrategy>
      <additionalClasspath></additionalClasspath>
    </javaposse.jobdsl.plugin.ExecuteDslScripts>
  </builders>
  <publishers/>
  <buildWrappers/>
</project>